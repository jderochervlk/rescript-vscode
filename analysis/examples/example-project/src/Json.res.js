// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Pervasives from "@rescript/runtime/lib/es6/Pervasives.js";
import * as Stdlib_List from "@rescript/runtime/lib/es6/Stdlib_List.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function string_of_number(f) {
  let s = f.toString();
  if (Primitive_object.equal(s[s.length - 1 | 0], ".")) {
    return s.slice(0, s.length - 1 | 0);
  } else {
    return s;
  }
}

function $pipe$bang(o, d) {
  if (o !== undefined) {
    return Primitive_option.valFromOption(o);
  } else {
    return Pervasives.failwith(d);
  }
}

function $pipe$question(o, d) {
  if (o !== undefined) {
    return Primitive_option.valFromOption(o);
  } else {
    return d;
  }
}

function $pipe$question$great(o, fn) {
  if (o !== undefined) {
    return fn(Primitive_option.valFromOption(o));
  }
}

function $pipe$question$great$great(o, fn) {
  if (o !== undefined) {
    return Primitive_option.some(fn(Primitive_option.valFromOption(o)));
  }
}

function fold(o, d, f) {
  if (o !== undefined) {
    return f(Primitive_option.valFromOption(o));
  } else {
    return d;
  }
}

let Infix = {
  $pipe$bang: $pipe$bang,
  $pipe$question: $pipe$question,
  $pipe$question$great: $pipe$question$great,
  $pipe$question$great$great: $pipe$question$great$great,
  fold: fold
};

function escape(text) {
  let ln = text.length;
  let _i = 0;
  let _acc = "";
  while (true) {
    let acc = _acc;
    let i = _i;
    if (i >= ln) {
      return acc;
    }
    let c = text[i];
    let next;
    if (c !== undefined) {
      switch (c) {
        case "\"" :
          next = acc + "\\\"";
          break;
        case "\\" :
          next = acc + "\\\\";
          break;
        case "\b" :
          next = acc + "\\b";
          break;
        case "\n" :
          next = acc + "\\n";
          break;
        case "\r" :
          next = acc + "\\r";
          break;
        case "\t" :
          next = acc + "\\t";
          break;
        case "\x0c" :
          next = acc + "\\f";
          break;
        default:
          next = acc + c;
      }
    } else {
      next = acc;
    }
    _acc = next;
    _i = i + 1 | 0;
    continue;
  };
}

function stringify(t) {
  if (typeof t !== "object") {
    switch (t) {
      case "True" :
        return "true";
      case "False" :
        return "false";
      case "Null" :
        return "null";
    }
  } else {
    switch (t.TAG) {
      case "String" :
        return "\"" + (escape(t._0) + "\"");
      case "Number" :
        return string_of_number(t._0);
      case "Array" :
        let join = (items, sep) => {
          if (items === 0) {
            return "";
          }
          let rest = items.tl;
          let x = items.hd;
          if (rest !== 0) {
            return x + sep + join(rest, sep);
          } else {
            return x;
          }
        };
        let parts = Stdlib_List.map(t._0, stringify);
        return "[" + join(parts, ", ") + "]";
      case "Object" :
        let join$1 = (items, sep) => {
          if (items === 0) {
            return "";
          }
          let rest = items.tl;
          let x = items.hd;
          if (rest !== 0) {
            return x + sep + join$1(rest, sep);
          } else {
            return x;
          }
        };
        let parts$1 = Stdlib_List.map(t._0, param => "\"" + (escape(param[0]) + ("\": " + stringify(param[1]))));
        return "{" + join$1(parts$1, ", ") + "}";
    }
  }
}

function white(n) {
  let _i = 0;
  let _acc = "";
  while (true) {
    let acc = _acc;
    let i = _i;
    if (i >= n) {
      return acc;
    }
    _acc = acc + " ";
    _i = i + 1 | 0;
    continue;
  };
}

function stringifyPretty(indentOpt, t) {
  let indent = indentOpt !== undefined ? indentOpt : 0;
  let join = (items, sep) => {
    if (items === 0) {
      return "";
    }
    let rest = items.tl;
    let x = items.hd;
    if (rest !== 0) {
      return x + sep + join(rest, sep);
    } else {
      return x;
    }
  };
  if (typeof t !== "object") {
    switch (t) {
      case "True" :
        return "true";
      case "False" :
        return "false";
      case "Null" :
        return "null";
    }
  } else {
    switch (t.TAG) {
      case "String" :
        return "\"" + (escape(t._0) + "\"");
      case "Number" :
        return string_of_number(t._0);
      case "Array" :
        let items = t._0;
        if (items === 0) {
          return "[]";
        }
        let parts = Stdlib_List.map(items, item => stringifyPretty(indent + 2 | 0, item));
        return "[\n" + white(indent + 2 | 0) + join(parts, ",\n" + white(indent + 2 | 0)) + "\n" + white(indent) + "]";
      case "Object" :
        let items$1 = t._0;
        if (items$1 === 0) {
          return "{}";
        }
        let parts$1 = Stdlib_List.map(items$1, param => "\"" + (escape(param[0]) + ("\": " + stringifyPretty(indent + 2 | 0, param[1]))));
        return "{\n" + white(indent + 2 | 0) + join(parts$1, ",\n" + white(indent + 2 | 0)) + "\n" + white(indent) + "}";
    }
  }
}

function unwrap(message, t) {
  if (t !== undefined) {
    return Primitive_option.valFromOption(t);
  } else {
    return Pervasives.failwith(message);
  }
}

function split_by(keep_emptyOpt, is_delim, str) {
  let keep_empty = keep_emptyOpt !== undefined ? keep_emptyOpt : false;
  let len = str.length;
  let _acc = /* [] */0;
  let _last_pos = len;
  let _pos = len - 1 | 0;
  while (true) {
    let pos = _pos;
    let last_pos = _last_pos;
    let acc = _acc;
    if (pos === -1) {
      if (last_pos === 0 && !keep_empty) {
        return acc;
      } else {
        return {
          hd: str.slice(0, last_pos),
          tl: acc
        };
      }
    }
    if (is_delim(str[pos])) {
      let new_len = (last_pos - pos | 0) - 1 | 0;
      if (new_len !== 0 || keep_empty) {
        let v = str.slice(pos + 1 | 0, (pos + 1 | 0) + new_len | 0);
        _pos = pos - 1 | 0;
        _last_pos = pos;
        _acc = {
          hd: v,
          tl: acc
        };
        continue;
      }
      _pos = pos - 1 | 0;
      _last_pos = pos;
      continue;
    }
    _pos = pos - 1 | 0;
    continue;
  };
}

function fail(text, pos, message) {
  let pre = text.slice(0, pos);
  let lines = split_by(undefined, c => Primitive_object.equal(c, "\n"), pre);
  let count = Stdlib_List.length(lines);
  let last = count > 0 ? Stdlib_List.getOrThrow(lines, count - 1 | 0) : "";
  let col = last.length + 1 | 0;
  let line = Stdlib_List.length(lines);
  return Pervasives.failwith("Error \"" + message + "\" at " + line.toString() + ":" + col.toString() + " -> " + last + "\n");
}

function skipToNewline(text, _pos) {
  while (true) {
    let pos = _pos;
    if (pos >= text.length) {
      return pos;
    }
    if (Primitive_object.equal(text[pos], "\n")) {
      return pos + 1 | 0;
    }
    _pos = pos + 1 | 0;
    continue;
  };
}

function stringTail(text) {
  let len = text.length;
  if (len > 1) {
    return text.slice(1, len);
  } else {
    return "";
  }
}

function skipToCloseMultilineComment(text, _pos) {
  while (true) {
    let pos = _pos;
    if ((pos + 1 | 0) >= text.length) {
      return Pervasives.failwith("Unterminated comment");
    }
    if (Primitive_object.equal(text[pos], "*") && Primitive_object.equal(text[pos + 1 | 0], "/")) {
      return pos + 2 | 0;
    }
    _pos = pos + 1 | 0;
    continue;
  };
}

function skipWhite(text, _pos) {
  while (true) {
    let pos = _pos;
    if (!(pos < text.length && (Primitive_object.equal(text[pos], " ") || Primitive_object.equal(text[pos], "\t") || Primitive_object.equal(text[pos], "\n") || Primitive_object.equal(text[pos], "\r")))) {
      return pos;
    }
    _pos = pos + 1 | 0;
    continue;
  };
}

function parseString(text, pos) {
  let ln = text.length;
  let loop = (_i, _acc) => {
    while (true) {
      let acc = _acc;
      let i = _i;
      if (i >= ln) {
        return fail(text, i, "Unterminated string");
      }
      let c = text[i];
      if (c === undefined) {
        return [
          i,
          acc
        ];
      }
      switch (c) {
        case "\"" :
          return [
            i + 1 | 0,
            acc
          ];
        case "\\" :
          if ((i + 1 | 0) >= ln) {
            return fail(text, i, "Unterminated string");
          }
          let match = text[i + 1 | 0];
          if (match !== undefined) {
            switch (match) {
              case "/" :
                _acc = acc + "/";
                _i = i + 2 | 0;
                continue;
              case "f" :
                _acc = acc + "\x0c";
                _i = i + 2 | 0;
                continue;
            }
          }
          let escaped = text.slice(i, i + 2 | 0);
          _acc = acc + escaped;
          _i = i + 2 | 0;
          continue;
          break;
        default:
          _acc = acc + c;
          _i = i + 1 | 0;
          continue;
      }
    };
  };
  let match = loop(pos, "");
  return [
    match[1],
    match[0]
  ];
}

function parseDigits(text, pos) {
  let len = text.length;
  let _i = pos + 1 | 0;
  while (true) {
    let i = _i;
    if (i >= len) {
      return i;
    }
    let match = text[i];
    if (match === undefined) {
      return i;
    }
    switch (match) {
      case "0" :
      case "1" :
      case "2" :
      case "3" :
      case "4" :
      case "5" :
      case "6" :
      case "7" :
      case "8" :
      case "9" :
        _i = i + 1 | 0;
        continue;
      default:
        return i;
    }
  };
}

function parseWithDecimal(text, pos) {
  let pos$1 = parseDigits(text, pos);
  if (pos$1 < text.length && Primitive_object.equal(text[pos$1], ".")) {
    return parseDigits(text, pos$1 + 1 | 0);
  } else {
    return pos$1;
  }
}

function parseNumber(text, pos) {
  let pos$1 = parseWithDecimal(text, pos);
  let ln = text.length;
  if (!(pos$1 < (ln - 1 | 0) && (Primitive_object.equal(text[pos$1], "E") || Primitive_object.equal(text[pos$1], "e")))) {
    return pos$1;
  }
  let match = text[pos$1 + 1 | 0];
  let pos$2;
  if (match !== undefined) {
    switch (match) {
      case "+" :
      case "-" :
        pos$2 = pos$1 + 2 | 0;
        break;
      default:
        pos$2 = pos$1 + 1 | 0;
    }
  } else {
    pos$2 = pos$1 + 1 | 0;
  }
  return parseDigits(text, pos$2);
}

function parseNegativeNumber(text, pos) {
  let final = Primitive_object.equal(text[pos], "-") ? parseNumber(text, pos + 1 | 0) : parseNumber(text, pos);
  let numStr = text.slice(pos, final);
  return [
    {
      TAG: "Number",
      _0: parseFloat(numStr)
    },
    final
  ];
}

function expect(char, text, pos, message) {
  if (Primitive_object.notequal(text[pos], char)) {
    return fail(text, pos, "Expected: " + message);
  } else {
    return pos + 1 | 0;
  }
}

function parseComment(text, pos, next) {
  if (Primitive_object.notequal(text[pos], "/")) {
    if (Primitive_object.equal(text[pos], "*")) {
      return next(text, skipToCloseMultilineComment(text, pos + 1 | 0));
    } else {
      return Pervasives.failwith("Invalid syntax");
    }
  } else {
    return next(text, skipToNewline(text, pos + 1 | 0));
  }
}

function maybeSkipComment(text, pos) {
  if (pos < text.length && Primitive_object.equal(text[pos], "/")) {
    if ((pos + 1 | 0) < text.length && Primitive_object.equal(text[pos + 1 | 0], "/")) {
      return skipToNewline(text, pos + 1 | 0);
    } else if ((pos + 1 | 0) < text.length && Primitive_object.equal(text[pos + 1 | 0], "*")) {
      return skipToCloseMultilineComment(text, pos + 1 | 0);
    } else {
      return fail(text, pos, "Invalid synatx");
    }
  } else {
    return pos;
  }
}

function skip(text, _pos) {
  while (true) {
    let pos = _pos;
    if (pos === text.length) {
      return pos;
    }
    let n = maybeSkipComment(text, skipWhite(text, pos));
    if (n <= pos) {
      return n;
    }
    _pos = n;
    continue;
  };
}

function parse(text, _pos) {
  while (true) {
    let pos = _pos;
    if (pos >= text.length) {
      return fail(text, pos, "Reached end of file without being done parsing");
    }
    let match = text[pos];
    if (match === undefined) {
      return fail(text, pos, "unexpected character");
    }
    switch (match) {
      case "/" :
        return parseComment(text, pos + 1 | 0, parse);
      case "-" :
      case "0" :
      case "1" :
      case "2" :
      case "3" :
      case "4" :
      case "5" :
      case "6" :
      case "7" :
      case "8" :
      case "9" :
        return parseNegativeNumber(text, pos);
      case "[" :
        return parseArray(text, pos + 1 | 0);
      case "\"" :
        let match$1 = parseString(text, pos + 1 | 0);
        return [
          {
            TAG: "String",
            _0: match$1[0]
          },
          match$1[1]
        ];
      case " " :
      case "\n" :
      case "\r" :
      case "\t" :
        break;
      case "f" :
        if (text.slice(pos, pos + 5 | 0) === "false") {
          return [
            "False",
            pos + 5 | 0
          ];
        } else {
          return fail(text, pos, "unexpected character");
        }
      case "n" :
        if (text.slice(pos, pos + 4 | 0) === "null") {
          return [
            "Null",
            pos + 4 | 0
          ];
        } else {
          return fail(text, pos, "unexpected character");
        }
      case "t" :
        if (text.slice(pos, pos + 4 | 0) === "true") {
          return [
            "True",
            pos + 4 | 0
          ];
        } else {
          return fail(text, pos, "unexpected character");
        }
      case "{" :
        return parseObject(text, pos + 1 | 0);
      default:
        return fail(text, pos, "unexpected character");
    }
    _pos = skipWhite(text, pos);
    continue;
  };
}

function parseArrayValue(text, pos) {
  let pos$1 = skip(text, pos);
  let match = parse(text, pos$1);
  let value = match[0];
  let pos$2 = skip(text, match[1]);
  let match$1 = text[pos$2];
  if (match$1 === undefined) {
    return fail(text, pos$2, "unexpected character");
  }
  switch (match$1) {
    case "," :
      let pos$3 = skip(text, pos$2 + 1 | 0);
      if (Primitive_object.equal(text[pos$3], "]")) {
        return [
          {
            hd: value,
            tl: /* [] */0
          },
          pos$3 + 1 | 0
        ];
      }
      let match$2 = parseArrayValue(text, pos$3);
      return [
        {
          hd: value,
          tl: match$2[0]
        },
        match$2[1]
      ];
    case "]" :
      return [
        {
          hd: value,
          tl: /* [] */0
        },
        pos$2 + 1 | 0
      ];
    default:
      return fail(text, pos$2, "unexpected character");
  }
}

function parseArray(text, pos) {
  let pos$1 = skip(text, pos);
  let match = text[pos$1];
  if (match === "]") {
    return [
      {
        TAG: "Array",
        _0: /* [] */0
      },
      pos$1 + 1 | 0
    ];
  }
  let match$1 = parseArrayValue(text, pos$1);
  return [
    {
      TAG: "Array",
      _0: match$1[0]
    },
    match$1[1]
  ];
}

function parseObjectValue(text, pos) {
  let pos$1 = skip(text, pos);
  if (Primitive_object.notequal(text[pos$1], "\"")) {
    return fail(text, pos$1, "Expected string");
  }
  let match = parseString(text, pos$1 + 1 | 0);
  let key = match[0];
  let pos$2 = skip(text, match[1]);
  let pos$3 = expect(":", text, pos$2, "Colon");
  let match$1 = parse(text, pos$3);
  let value = match$1[0];
  let pos$4 = skip(text, match$1[1]);
  let match$2 = text[pos$4];
  if (match$2 !== undefined) {
    switch (match$2) {
      case "," :
        let pos$5 = skip(text, pos$4 + 1 | 0);
        if (Primitive_object.equal(text[pos$5], "}")) {
          return [
            {
              hd: [
                key,
                value
              ],
              tl: /* [] */0
            },
            pos$5 + 1 | 0
          ];
        }
        let match$3 = parseObjectValue(text, pos$5);
        return [
          {
            hd: [
              key,
              value
            ],
            tl: match$3[0]
          },
          match$3[1]
        ];
      case "}" :
        return [
          {
            hd: [
              key,
              value
            ],
            tl: /* [] */0
          },
          pos$4 + 1 | 0
        ];
    }
  }
  let match$4 = parseObjectValue(text, pos$4);
  return [
    {
      hd: [
        key,
        value
      ],
      tl: match$4[0]
    },
    match$4[1]
  ];
}

function parseObject(text, pos) {
  let pos$1 = skip(text, pos);
  if (Primitive_object.equal(text[pos$1], "}")) {
    return [
      {
        TAG: "Object",
        _0: /* [] */0
      },
      pos$1 + 1 | 0
    ];
  }
  let match = parseObjectValue(text, pos$1);
  return [
    {
      TAG: "Object",
      _0: match[0]
    },
    match[1]
  ];
}

let Parser = {
  split_by: split_by,
  fail: fail,
  skipToNewline: skipToNewline,
  stringTail: stringTail,
  skipToCloseMultilineComment: skipToCloseMultilineComment,
  skipWhite: skipWhite,
  parseString: parseString,
  parseDigits: parseDigits,
  parseWithDecimal: parseWithDecimal,
  parseNumber: parseNumber,
  parseNegativeNumber: parseNegativeNumber,
  expect: expect,
  parseComment: parseComment,
  maybeSkipComment: maybeSkipComment,
  skip: skip,
  parse: parse,
  parseArrayValue: parseArrayValue,
  parseArray: parseArray,
  parseObjectValue: parseObjectValue,
  parseObject: parseObject
};

function parse$1(text) {
  let match = parse(text, 0);
  let pos = skip(text, match[1]);
  if (pos < text.length) {
    return Pervasives.failwith("Extra data after parse finished: " + text.slice(pos, text.length));
  } else {
    return match[0];
  }
}

function bind(v, fn) {
  if (v !== undefined) {
    return fn(Primitive_option.valFromOption(v));
  }
}

function get(key, t) {
  if (typeof t !== "object") {
    return;
  }
  if (t.TAG !== "Object") {
    return;
  }
  let _items = t._0;
  while (true) {
    let items = _items;
    if (items === 0) {
      return;
    }
    let match = items.hd;
    if (match[0] === key) {
      return Primitive_option.some(match[1]);
    }
    _items = items.tl;
    continue;
  };
}

function nth(n, t) {
  if (typeof t !== "object") {
    return;
  }
  if (t.TAG !== "Array") {
    return;
  }
  let items = t._0;
  if (n < Stdlib_List.length(items)) {
    return Stdlib_List.getOrThrow(items, n);
  }
}

function string(t) {
  if (typeof t !== "object" || t.TAG !== "String") {
    return;
  } else {
    return t._0;
  }
}

function number(t) {
  if (typeof t !== "object" || t.TAG !== "Number") {
    return;
  } else {
    return t._0;
  }
}

function array(t) {
  if (typeof t !== "object" || t.TAG !== "Array") {
    return;
  } else {
    return t._0;
  }
}

function obj(t) {
  if (typeof t !== "object" || t.TAG !== "Object") {
    return;
  } else {
    return t._0;
  }
}

function bool(t) {
  if (typeof t === "object") {
    return;
  }
  switch (t) {
    case "True" :
      return true;
    case "False" :
      return false;
    default:
      return;
  }
}

function $$null(t) {
  if (typeof t !== "object" && t === "Null") {
    return Primitive_option.some(undefined);
  }
}

function parsePath(_keyList, _t) {
  while (true) {
    let t = _t;
    let keyList = _keyList;
    if (keyList === 0) {
      return t;
    }
    let value = get(keyList.hd, t);
    if (value === undefined) {
      return;
    }
    _t = value;
    _keyList = keyList.tl;
    continue;
  };
}

function getPath(path, t) {
  let keys = split_by(undefined, c => Primitive_object.equal(c, "."), path);
  return parsePath(keys, t);
}

export {
  string_of_number,
  Infix,
  escape,
  stringify,
  white,
  stringifyPretty,
  unwrap,
  Parser,
  parse$1 as parse,
  bind,
  get,
  nth,
  string,
  number,
  array,
  obj,
  bool,
  $$null,
  parsePath,
  getPath,
}
/* No side effect */
